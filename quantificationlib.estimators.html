

<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>quantificationlib.estimators package &#8212; quantificationlib 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/bizstyle.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">quantificationlib 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quantificationlib.estimators package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="quantificationlib-estimators-package">
<h1>quantificationlib.estimators package<a class="headerlink" href="#quantificationlib-estimators-package" title="Permalink to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">¶</a></h2>
</section>
<section id="module-quantificationlib.estimators.cross_validation">
<span id="quantificationlib-estimators-cross-validation-module"></span><h2>quantificationlib.estimators.cross_validation module<a class="headerlink" href="#module-quantificationlib.estimators.cross_validation" title="Permalink to this heading">¶</a></h2>
<p>Estimator object based on Cross Validation</p>
<dl class="py class">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CV_estimator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'warn'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_dispatch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2*n_jobs'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">averaged_predictions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hard'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/cross_validation.html#CV_estimator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ClassifierMixin</span></code></p>
<p>Cross Validation Estimator</p>
<p>The idea is to have an estimator in which the model is formed by the models of a CV. This object is needed
to estimate the distribution of the training set and testing sets. It has a <cite>fit</cite> method, that trains
the models of the CV, and the typical methods <cite>predict</cite> y <cite>predict_proba</cite> to compute the predictions using
such models. This implies that this object can be used by any distribution matching method that requires an
estimator to represent the distributions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sklearn</strong> (<em>Mainly the same that cross_validate method in</em>) – </p></li>
<li><p><strong>estimator</strong> (<em>estimator object implementing 'fit'</em>) – The object to use to fit the data.</p></li>
<li><p><strong>groups</strong> (<em>array-like</em><em>, </em><em>with shape</em><em> (</em><em>n_samples</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Group labels for the samples used while splitting the dataset into train/test set.</p></li>
<li><p><strong>cv</strong> (<em>int</em><em>, </em><em>cross-validation generator</em><em> or </em><em>an iterable</em><em>, </em><em>optional</em>) – <p>Determines the cross-validation splitting strategy. Possible inputs for cv are:</p>
<ul>
<li><p>None, to use the default 3-fold cross validation,</p></li>
<li><p>integer, to specify the number of folds in a <cite>(Stratified)KFold</cite>,</p></li>
<li><p><span class="xref std std-term">CV splitter</span>,</p></li>
<li><p>An iterable yielding (train, test) splits as arrays of indices.</p></li>
</ul>
<p>For integer/None inputs, if the estimator is a classifier and <code class="docutils literal notranslate"><span class="pre">y</span></code> is either binary or multiclass,
<code class="xref py py-class docutils literal notranslate"><span class="pre">StratifiedKFold</span></code> is used. In all other cases, <code class="xref py py-class docutils literal notranslate"><span class="pre">KFold</span></code> is used.</p>
</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The number of CPUs to use to do the computation.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors.</p></li>
<li><p><strong>fit_params</strong> (<em>dict</em><em>, </em><em>optional</em>) – Parameters to pass to the fit method of the estimator.</p></li>
<li><p><strong>pre_dispatch</strong> (<em>int</em><em>, or </em><em>string</em><em>, </em><em>optional</em>) – <p>Controls the number of jobs that get dispatched during parallel execution. Reducing this number can be
useful to avoid an explosion of memory consumption when more jobs get dispatched than CPUs can process.
This parameter can be:
- None, in which case all the jobs are immediately</p>
<blockquote>
<div><p>created and spawned. Use this for lightweight and
fast-running jobs, to avoid delays due to on-demand
spawning of the jobs</p>
</div></blockquote>
<ul>
<li><p>An int, giving the exact number of total jobs that are
spawned</p></li>
<li><p>A string, giving an expression as a function of n_jobs,
as in ‘2*n_jobs’</p></li>
</ul>
</p></li>
<li><p><strong>averaged_predictions</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, <cite>predict`and `predict_proba</cite> methods average the predictions given by <a href="#id5"><span class="problematic" id="id6">estimators_</span></a> for
each example</p></li>
<li><p><strong>voting</strong> (<em>str</em><em>, </em><em>{'hard'</em><em>, </em><em>'soft'}</em><em> (</em><em>default='hard'</em><em>)</em>) – Only used when averaged_predictions is True.
If ‘hard’, <cite>predict`and `predict_proba</cite> methods apply majority rule voting.
If ‘soft’, predict the class label based on the argmax of the sums of the predicted probabilities,
which is recommended for an ensemble of well-calibrated classifiers.</p></li>
<li><p><strong>verbose</strong> (<em>integer</em><em>, </em><em>optional</em><em> (</em><em>default=0</em><em>)</em>) – The verbosity level.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">In</span> <span class="pre">addition</span> <span class="pre">to</span> <span class="pre">the</span> <span class="pre">parameters</span> <span class="pre">needed</span> <span class="pre">to</span> <span class="pre">call</span> <span class="pre">`cross_validate``</span> <span class="pre">the</span> <span class="pre">class</span> <span class="pre">has</span> <span class="pre">this</span> <span class="pre">important</span> <span class="pre">attributes</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.estimator">
<span class="sig-name descname"><span class="pre">estimator</span></span><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>The estimator to fit each model of the CV</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>An estimator object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.estimators_">
<span class="sig-name descname"><span class="pre">estimators_</span></span><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.estimators_" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of estimators trained by <a href="#id1"><span class="problematic" id="id2">`</span></a>fit`method.
The number of estimators is equal to the number of folds times number of repetitions</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of trained estimators</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.averaged_predictions">
<span class="sig-name descname"><span class="pre">averaged_predictions</span></span><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.averaged_predictions" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether the predictions for each example given by <a href="#id7"><span class="problematic" id="id8">estimators_</span></a> are averaged or not</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.voting">
<span class="sig-name descname"><span class="pre">voting</span></span><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.voting" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>How predictions are aggregated:</dt><dd><ul class="simple">
<li><p>‘hard’, applying majority rule voting</p></li>
<li><p>‘soft’, based on the argmax of the sums of the predicted probabilities</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str, {‘hard’, ‘soft’} (default=’hard’)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.le_">
<span class="sig-name descname"><span class="pre">le_</span></span><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.le_" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to compute the class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>a LabelEncoder fitted object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.classes_" title="Permalink to this definition">¶</a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.X_train_">
<span class="sig-name descname"><span class="pre">X_train_</span></span><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.X_train_" title="Permalink to this definition">¶</a></dt>
<dd><p>Data. It is needed to obtain the predictions over the own training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_examples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.y_train_">
<span class="sig-name descname"><span class="pre">y_train_</span></span><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.y_train_" title="Permalink to this definition">¶</a></dt>
<dd><p>True classes. It is needed to obtain the predictions over the own training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape (n_examples, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>The verbosity level.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>integer</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/cross_validation.html#CV_estimator.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the models
It calls <cite>cross_validate</cite> to fit the models and save them in <a href="#id9"><span class="problematic" id="id10">estimators_</span></a> attribute.
It also stores some attributes needed by <cite>predict</cite> and <cite>predict_proba</cite>, namely, <a href="#id11"><span class="problematic" id="id12">le_</span></a>, <a href="#id13"><span class="problematic" id="id14">classes_</span></a> X_train
and <a href="#id15"><span class="problematic" id="id16">y_train_</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/cross_validation.html#CV_estimator.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the crisp predictions given by a CV estimator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Test ata</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>preds</strong> –    the value of averaged_predictions attribute</p>
<dl class="simple">
<dt>Training set:</dt><dd><ul class="simple">
<li><p>averaged_predictions == True,  shape(n_examples, )</p></li>
<li><p>averaged_predictions == False, shape(n_examples * n_reps, )</p></li>
</ul>
</dd>
<dt>Testing set:</dt><dd><ul class="simple">
<li><p>averaged_predictions == True,  shape(n_examples, )</p></li>
<li><p>averaged_predictions == False, shape(n_examples * n_reps * n_folds, )</p></li>
</ul>
</dd>
</dl>
<p>Crisp predictions for the examples in X</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape depends on two factors: the type of the examples (training or testing) and</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.cross_validation.CV_estimator.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/cross_validation.html#CV_estimator.predict_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.cross_validation.CV_estimator.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns probabilistic predictions given by a CV estimator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Test ata</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>preds</strong> –     the value of averaged_predictions attribute</p>
<p>Probabilistic predictions for the examples in X.
Shape:</p>
<blockquote>
<div><dl class="simple">
<dt>Training set:</dt><dd><ul class="simple">
<li><p>averaged_predictions == True,  shape(n_examples, n_classes)</p></li>
<li><p>averaged_predictions == False, shape(n_examples * n_reps, n_classes)</p></li>
</ul>
</dd>
<dt>Testing set:</dt><dd><ul class="simple">
<li><p>averaged_predictions == True,  shape(n_examples, n_classes)</p></li>
<li><p>averaged_predictions == False, shape(n_examples * n_reps * n_folds, n_classes)</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape depends on two factors: the type of the examples (training or testing) and</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-quantificationlib.estimators.ensembles">
<span id="quantificationlib-estimators-ensembles-module"></span><h2>quantificationlib.estimators.ensembles module<a class="headerlink" href="#module-quantificationlib.estimators.ensembles" title="Permalink to this heading">¶</a></h2>
<p>Estimators for an Ensemble of Quantifiers</p>
<dl class="py class">
<dt class="sig sig-object py" id="quantificationlib.estimators.ensembles.EnsembleOfClassifiers">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EnsembleOfClassifiers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/ensembles.html#EnsembleOfClassifiers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ClassifierMixin</span></code></p>
<p>Ensemble of Classifiers</p>
<p>This kind of objects train the set of classifiers for an ensemble of quantifiers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>base_estimator</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is the base estimator
used to learn the set of classifiers</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The number of jobs to use for the computation.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <span class="xref std std-term">Glossary</span>
for more details.</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ensembles.EnsembleOfClassifiers.base_estimator">
<span class="sig-name descname"><span class="pre">base_estimator</span></span><a class="headerlink" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.base_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>The base estimator used to build ensemble</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ensembles.EnsembleOfClassifiers.n_jobs">
<span class="sig-name descname"><span class="pre">n_jobs</span></span><a class="headerlink" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.n_jobs" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of jobs to use for the computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int or None,</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ensembles.EnsembleOfClassifiers.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>The verbosity level. The default value, zero, means silent mode</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ensembles.EnsembleOfClassifiers.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.classes_" title="Permalink to this definition">¶</a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ensembles.EnsembleOfClassifiers.n_estimators_">
<span class="sig-name descname"><span class="pre">n_estimators_</span></span><a class="headerlink" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.n_estimators_" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of estimators</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int,</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ensembles.EnsembleOfClassifiers.estimators_">
<span class="sig-name descname"><span class="pre">estimators_</span></span><a class="headerlink" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.estimators_" title="Permalink to this definition">¶</a></dt>
<dd><p>List of estimators</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(n_ensembles,)</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<p>Pérez-Gállego, P., Quevedo, J. R., &amp; del Coz, J. J. (2017). Using ensembles for problems with characterizable
changes in data distribution: A case study on quantification. Information Fusion, 34, 87-100.</p>
<p>Pérez-Gállego, P., Castano, A., Quevedo, J. R., &amp; del Coz, J. J. (2019). Dynamic ensemble selection
for quantification tasks. Information Fusion, 45, 1-15.</p>
<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.ensembles.EnsembleOfClassifiers.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indexes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/ensembles.html#EnsembleOfClassifiers.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the set of estimators for the training set (X, y) using the bags contained in indexes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
<li><p><strong>indexes</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_ensembles</em><em>, </em><em>bag_size</em><em>)</em>) – i-th row contains the indexes of the examples in (X, y) that must be used to train i-th estimator</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When base_estimator is None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.ensembles.EnsembleOfClassifiers.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/ensembles.html#EnsembleOfClassifiers.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the class for each testing example applying each estimator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>An array, shape(n_examples, n_estimators) with the predicted class for each example with each estimator</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotFittedError</strong> – When the estimators are not fitted yet</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.ensembles.EnsembleOfClassifiers.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/ensembles.html#EnsembleOfClassifiers.predict_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the class probabilities for each example `</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>An array, shape(n_examples, n_estimators, n_classes) with the predicted class for each example with each</em></p></li>
<li><p><em>estimator</em></p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotFittedError</strong> – When the estimators are not fitted yet</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-quantificationlib.estimators.frank_and_hall">
<span id="quantificationlib-estimators-frank-and-hall-module"></span><h2>quantificationlib.estimators.frank_and_hall module<a class="headerlink" href="#module-quantificationlib.estimators.frank_and_hall" title="Permalink to this heading">¶</a></h2>
<p>Estimators based on Frank and Hall decomposition</p>
<dl class="py class">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FHLabelBinarizer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FHLabelBinarizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">neg_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FHLabelBinarizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FHLabelBinarizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">LabelBinarizer</span></code></p>
<p>Binarize labels in a Frank and Hall decomposition</p>
<p>This type of decomposition works as follows. For instance, in a ordinal classification problem with classes
ranging from 1-star to 5-star, Frank and Hall (FH) decompositon trains 4 binary classifiers:
1 vs 2-3-4-5, 1-2 vs 3-4-5, 1-2-3 vs 4-5, 1-2-3-4 vs 5 and combines their predictions.</p>
<p>To train all these binary classifiers, one needs to convert the original ordinal labels to binary labels
for each of the binary problems of the Frank and Hall decomposition. FHLabelBinarizer makes this process
easy using the transform method.</p>
<blockquote>
<div><dl class="simple">
<dt>neg_label<span class="classifier">int (default: 0)</span></dt><dd><p>Value with which negative labels must be encoded.</p>
</dd>
<dt>pos_label<span class="classifier">int (default: 1)</span></dt><dd><p>Value with which positive labels must be encoded.</p>
</dd>
<dt>sparse_output<span class="classifier">boolean (default: False)</span></dt><dd><p>True if the returned array from transform is desired to be in sparse CSR format.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FHLabelBinarizer.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FHLabelBinarizer.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FHLabelBinarizer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform ordinal labels to the Frank and Hall binary labels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>y</strong> (<em>array</em><em>, </em><em>(</em><em>n_samples</em><em>,</em><em>)</em>) – Class labels for a set of examples</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>y_bin_fh</strong> – Each column contains the binary labels for the consecutive binary problems of a Frank and Hall
decomposition from left to right. For instance, in a 4-class problem, each column corresponds to
the following problems:</p>
<p>1st column: 1 vs 2-3-4
2nd column: 1-2 vs 3-4
3rd column: 1-2-3 vs 4
4ht column: (not really used)</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, (n_samples, n_classes)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FrankAndHallClassifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params_fit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallClassifier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ClassifierMixin</span></code></p>
<p>Ordinal Classifier following Frank and Hall binary decomposition</p>
<p>This type of decomposition works as follows. For instance, in a ordinal classification problem with classes
ranging from 1-star to 5-star, Frank and Hall (FH) decompositon trains 4 binary classifiers:
1 vs 2-3-4-5, 1-2 vs 3-4-5, 1-2-3 vs 4-5, 1-2-3-4 vs 5 and combines their predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is the base estimator
used to learn the set of binary classifiers</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The number of jobs to use for the computation.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <span class="xref std std-term">Glossary</span>
for more details.</p></li>
<li><p><strong>params_fit</strong> (<em>list</em><em> of </em><em>dictionaries with parameters for each binary estimator</em><em>, </em><em>optional</em>) – <p>Example: 5 classes/4 binary estimators:</p>
<blockquote>
<div><p>params_fit = [{‘C’:0.0001} , {‘C’:0.000001}, {‘C’:0.000001}, {‘C’:0.01}]</p>
</div></blockquote>
</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.estimator">
<span class="sig-name descname"><span class="pre">estimator</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>The base estimator used to build the FH decomposition</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.n_jobs">
<span class="sig-name descname"><span class="pre">n_jobs</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.n_jobs" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of jobs to use for the computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int or None,</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.params_fit">
<span class="sig-name descname"><span class="pre">params_fit</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.params_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>It has the parameters for each binary estimator</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of dictionaries</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>The verbosity level. The default value, zero, means silent mode</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.classes_" title="Permalink to this definition">¶</a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.estimators_">
<span class="sig-name descname"><span class="pre">estimators_</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.estimators_" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>List of binary estimators following the same order of the Frank and Hall decomposition:</dt><dd><p>estimators_[0] -&gt; 1 vs 2-3-4-5
estimators_[1] -&gt; 1-2 vs 3-4-5
…</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(n_classes-1,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.label_binarizer_">
<span class="sig-name descname"><span class="pre">label_binarizer_</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.label_binarizer_" title="Permalink to this definition">¶</a></dt>
<dd><p>Object used to transform multiclass labels to binary labels and vice-versa</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>FHLabelBinarizer object</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<p>Eibe Frank and Mark Hall. 2001. A simple approach to ordinal classification.
In Proceedings of the European Conference on Machine Learning. Springer, 145156.</p>
<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.compute_binary_proba">
<span class="sig-name descname"><span class="pre">compute_binary_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallClassifier.compute_binary_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.compute_binary_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the class probabilities of the internal binary estimators</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>For each sample, this matrix contains the probabily that such sample belongs to left group of classes
of each estimator of the FH decomposition
Recall that n_estimators = n_classes-1</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(n_samples, n_estimators)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallClassifier.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the set of estimators for the training set following the Frank and Hall decomposition</p>
<dl class="simple">
<dt>It learns a list of binary estimators following the same order of the Frank and Hall decomposition:</dt><dd><p>estimators_[0] -&gt; 1 vs 2-3-4-5
estimators_[1] -&gt; 1-2 vs 3-4-5
…</p>
</dd>
</dl>
<p>The left group of each classifier ({1}, {1,2}, …) is the positive class</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator is None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallClassifier.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the class for each testing example</p>
<p>The method computes the probability of each class (using <cite>predict_proba</cite>) and returns the class with
highest probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>An array, shape(n_examples, ) with the predicted class for each example</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotFittedError</strong> – When the estimators are not fitted yet</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallClassifier.predict_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the class probabilities for each example following the original rule proposed by Frank &amp; Hall</p>
<blockquote>
<div><p>If the classes are c_1 to c_k:</p>
<blockquote>
<div><p>Pr(y = c_1) = Pr (y &lt;= c_1)
Pr(y = c_i) = Pr(y &gt; c_i−1)  x (1 − Pr(y &gt; c_i)) ; 1 &lt; i &lt; k
Pr(y = c_k) = Pr(y &gt; c_k−1)</p>
<p>Notice that :  :math:<a href="#id3"><span class="problematic" id="id4">`</span></a>sum_{i=1}^{i=k} Pr(c_i)</p>
</div></blockquote>
</div></blockquote>
<p>eq 1`</p>
<blockquote>
<div><p>Example with 5 classes</p>
<blockquote>
<div><p>We have 4 binary estimators that return two probabilities: the probability of the left group and the
probability of the right group, denoted as e_i.left and e_i.right respectively, in which i is the
number of the estimator 1&lt;=i&lt;k</p>
<p>Estimator 0:    c1  |   c2, c3, c4, c5          e1.left | e1.right
Estimator 2:    c1, c2  |   c3, c4, c5          e2.left | e2.right
Estimator 3:    c1, c2, c3  |   c4, c5          e3.left | e3.right
Estimator 4:    c1, c2, c3  c4  |   c5          e4.left | e4.right</p>
<p>Pr(y = c_1) = e1.left
Pr(y = c_2) = e1.right x e2.left
Pr(y = c_3) = e2.right x e3.left
Pr(y = c_4) = e3.right x e4.left
Pr(y = c_5) = e4.right</p>
</div></blockquote>
<dl class="simple">
<dt>X<span class="classifier">(sparse) array-like, shape (n_examples, n_features)</span></dt><dd><p>Data</p>
</dd>
</dl>
<p>An array, shape(n_examples, n_classes) with the class probabilities for each example</p>
<dl class="simple">
<dt>NotFittedError</dt><dd><p>When the estimators are not fitted yet</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FrankAndHallMonotoneClassifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params_fit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallMonotoneClassifier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="rsts_t4/quantificationlib.estimators.frank_and_hall.html#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier" title="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">FrankAndHallClassifier</span></code></a></p>
<p>Ordinal Classifier following Frank and Hall binary decomposition but returning consistent probabilities</p>
<p>This type of decomposition works as follows. For instance, in a ordinal classification problem with classes
ranging from 1-star to 5-star, Frank and Hall (FH) decompositon trains 4 binary classifiers:
1 vs 2-3-4-5, 1-2 vs 3-4-5, 1-2-3 vs 4-5, 1-2-3-4 vs 5 and combines their predictions.</p>
<p>The difference with FrankAndHallClassifier is that the original method devised by Frank &amp; Hall was intented
just for crips predictions. The computed probabilities for all classes may be not consistent (their sum is
not 1 in many cases)</p>
<p>Following (Destercke, Yang, 2014) this class computes the upper (adjusting from  left to right) and the lower
(from right to left) cumulative probabilities for each group of classes. These sets of values are
monotonically increasing (from left to right) and monotonically decreasing (from right to left), respectively.
The final probability assigned to each group is the average of both values, and the probality of each class
is computed as:</p>
<blockquote>
<div><p>Pr({y_k}) = Pr({y_1,…,y_k}) - Pr({y_1,…,y_k-1})</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is the base estimator
used to learn the set of binary classifiers</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The number of jobs to use for the computation.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <span class="xref std std-term">Glossary</span>
for more details.</p></li>
<li><p><strong>params_fit</strong> (<em>list</em><em> of </em><em>dictionaries with parameters for each binary estimator</em><em>, </em><em>optional</em>) – <p>Example: 5 classes/4 binary estimators:</p>
<blockquote>
<div><p>params_fit = [{‘C’:0.0001} , {‘C’:0.000001}, {‘C’:0.000001}, {‘C’:0.01}]</p>
</div></blockquote>
</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.estimator">
<span class="sig-name descname"><span class="pre">estimator</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>The base estimator used to build the FH decomposition</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.n_jobs">
<span class="sig-name descname"><span class="pre">n_jobs</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.n_jobs" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of jobs to use for the computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int or None,</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>The verbosity level. The default value, zero, means silent mode</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.params_fit">
<span class="sig-name descname"><span class="pre">params_fit</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.params_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>It has the parameters for each binary estimator (not used in this class)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of dictionaries</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.classes_" title="Permalink to this definition">¶</a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.estimators_">
<span class="sig-name descname"><span class="pre">estimators_</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.estimators_" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>List of binary estimators following the same order of the Frank and Hall decomposition:</dt><dd><p>estimators_[0] -&gt; 1 vs 2-3-4-5
estimators_[1] -&gt; 1-2 vs 3-4-5
…</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(n_classes-1,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.label_binarizer_">
<span class="sig-name descname"><span class="pre">label_binarizer_</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.label_binarizer_" title="Permalink to this definition">¶</a></dt>
<dd><p>Object used to transform multiclass labels to binary labels and vice-versa</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>FHLabelBinarizer object</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<p>Sébastien Destercke, Gen Yang. Cautious Ordinal Classification by Binary Decomposition.
Machine Learning and Knowledge Discovery in Databases - European Conference ECML/PKDD,
Sep 2014, Nancy, France. pp.323 - 337, 2014,</p>
<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallMonotoneClassifier.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the set of estimators for the training set following the Frank and Hall decomposition</p>
<dl class="simple">
<dt>It learns a list of binary estimators following the same order of the Frank and Hall decomposition:</dt><dd><p>estimators_[0] -&gt; 1 vs 2-3-4-5
estimators_[1] -&gt; 1-2 vs 3-4-5
…</p>
</dd>
</dl>
<p>The left group of each classifier ({1}, {1,2}, …) is the positive class</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator is None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallMonotoneClassifier.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the class for each testing example</p>
<p>The method computes the probability of each class (using <cite>predict_proba</cite>) and returns the class with
highest probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>An array, shape(n_examples, ) with the predicted class for each example</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotFittedError</strong> – When the estimators are not fitted yet</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallMonotoneClassifier.predict_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the class probabilities for each example following a new rule (different from the original
one proposed by Frank &amp; Hall)</p>
<p>To obtain consistent probabilities, we need to ensure that the aggregated consecutive
probabilities do not decrease.</p>
<p class="rubric">Example</p>
<p>Classifier 1 vs 2-3-4   Pr({1}) = 0.3
Classifier 1-2 vs 3-4   Pr({1,2}) = 0.2
Classifier 1-2-3 vs 4   Pr({1,2,3}) = 0.6</p>
<p>This is inconsistent. Following (Destercke and Yang, 2014) the method computes the upper (adjusting from
left to right) and the lower (from right to left) cumulative probabilities. These sets of values are
monotonically increasing (from left to right) and monotonically decreasing (from right to left),
respectively. The average value is assigned to each group and the probability for each class is computed as:</p>
<blockquote>
<div><p>Pr({y_k}) = Pr({y_1,…,y_k}) - Pr({y_1,…,y_k-1})</p>
</div></blockquote>
<p class="rubric">Example</p>
<p>{1}   {1-2}  {1-2-3}</p>
<p>0.3   0.3    0.6    Upper cumulative probabilities (adjusting from left to right)</p>
<section id="lower-cumulative-probabilities-adjusting-from-right-to-left">
<h3>0.2   0.2    0.6    Lower cumulative probabilities (adjusting from right to left)<a class="headerlink" href="#lower-cumulative-probabilities-adjusting-from-right-to-left" title="Permalink to this heading">¶</a></h3>
<p>0.25  0.25   0.6    Averaged probability</p>
<p>Pr({1}) = 0.25
Pr({2}) = Pr({1,2}) - Pr({1}) = 0.25 - 0 .25 = 0
Pr({3}) = Pr({1,2,3}} - Pr({1,2}) = 0.6 - 0.25 = 0.35</p>
<p>The last class is computed as 1 - the sum of the probabilities for the rest of classes</p>
<p>Pr({4}) = 1 - Pr({1,2,3}} = 1 - 0.6 = 0.4</p>
<dl class="field-list simple">
<dt class="field-odd">param X<span class="colon">:</span></dt>
<dd class="field-odd"><p>Data</p>
</dd>
<dt class="field-even">type X<span class="colon">:</span></dt>
<dd class="field-even"><p>(sparse) array-like, shape (n_examples, n_features)</p>
</dd>
<dt class="field-odd">rtype<span class="colon">:</span></dt>
<dd class="field-odd"><p>An array, shape(n_examples, n_classes) with the class probabilities for each example</p>
</dd>
<dt class="field-even">raises NotFittedError<span class="colon">:</span></dt>
<dd class="field-even"><p>When the estimators are not fitted yet</p>
</dd>
</dl>
</section>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FrankAndHallTreeClassifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">performance_measure=&lt;function</span> <span class="pre">binary_kld&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params_fit=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallTreeClassifier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="rsts_t4/quantificationlib.estimators.frank_and_hall.html#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier" title="quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">FrankAndHallClassifier</span></code></a></p>
<p>Ordinal Classifier following Frank and Hall binary decomposition but organizing the binary models in a
tree to compute the predictions</p>
<p>This type of decomposition works as follows. For instance, in a ordinal classification problem with classes
ranging from 1-star to 5-star, Frank and Hall (FH) decompositon trains 4 binary classifiers:
1 vs 2-3-4-5, 1-2 vs 3-4-5, 1-2-3 vs 4-5, 1-2-3-4 vs 5 and combines their predictions.</p>
<p>The difference with FrankAndHallClassifier is that the original method devised by Frank &amp; Hall computes the
probability of each class applying the binary models from left to right: 1 vs 2-3-4-5, 1-2 vs 3-4-5, and so on.
This classifier is based on the method proposed by (San Martino, Gao and Sebastiani, 2016). The idea is to
build a binary tree with the binary models of the Frank and Hall decomposition, selecting at each point of the
tree the best possible model according to their quantification performance (applying PCC algorithm with each
binary classifier and using the KLD as performance measure).</p>
<p class="rubric">Example</p>
<p>1-2-3 vs 4-5</p>
<blockquote>
<div><blockquote>
<div><p>1 vs 2-3-4-5                            1-2-3-4 vs 5</p>
</div></blockquote>
<dl class="simple">
<dt>1                1-2 vs 3-4-5           4                5</dt><dd><p>2              3</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is the base estimator
used to learn the set of binary classifiers</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The number of jobs to use for the computation.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <span class="xref std std-term">Glossary</span>
for more details.</p></li>
<li><p><strong>performance_measure</strong> (<em>a binary quantification performance measure</em><em>, </em><em>(</em><em>default=binary_kld</em><em>)</em>) – The binary quantification performance measure used to estimate the goodness of each binary classifier used
as quantifier</p></li>
<li><p><strong>params_fit</strong> (<em>list</em><em> of </em><em>dictionaries with parameters for each binary estimator</em><em>, </em><em>optional</em>) – <p>Example: 5 classes/4 binary estimators:</p>
<blockquote>
<div><p>params_fit = [{‘C’:0.0001} , {‘C’:0.000001}, {‘C’:0.000001}, {‘C’:0.01}]</p>
</div></blockquote>
</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.estimator">
<span class="sig-name descname"><span class="pre">estimator</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>The base estimator used to build the FH decomposition</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.n_jobs">
<span class="sig-name descname"><span class="pre">n_jobs</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.n_jobs" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of jobs to use for the computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int or None,</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.performance_measure">
<span class="sig-name descname"><span class="pre">performance_measure</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.performance_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>The binary quantification performance measure used to estimate the goodness of each binary classifier used
as quantifier</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str, or any binary quantification performance measure</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>The verbosity level. The default value, zero, means silent mode</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.params_fit">
<span class="sig-name descname"><span class="pre">params_fit</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.params_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>It has the parameters for each binary estimator</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of dictionaries</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.classes_" title="Permalink to this definition">¶</a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.estimators_">
<span class="sig-name descname"><span class="pre">estimators_</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.estimators_" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>List of binary estimators following the same order of the Frank and Hall decomposition:</dt><dd><p>estimators_[0] -&gt; 1 vs 2-3-4-5
estimators_[1] -&gt; 1-2 vs 3-4-5
…</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(n_classes-1,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.label_binarizer_">
<span class="sig-name descname"><span class="pre">label_binarizer_</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.label_binarizer_" title="Permalink to this definition">¶</a></dt>
<dd><p>Object used to transform multiclass labels to binary labels and vice-versa</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>FHLabelBinarizer object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.tree_">
<span class="sig-name descname"><span class="pre">tree_</span></span><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.tree_" title="Permalink to this definition">¶</a></dt>
<dd><p>A tree with the binary classifiers ordered by their quantification performance (using KLD or other measure)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A tree</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<p>Giovanni Da San Martino, Wei Gao, and Fabrizio Sebastiani. 2016a. Ordinal text quantification.
In Proceedings of the International ACM SIGIR Conference on  Research and Development
in Information Retrieval. 937940.</p>
<p>Giovanni Da San Martino,Wei Gao, and Fabrizio Sebastiani. 2016b.
QCRI at SemEval-2016 Task 4: Probabilistic methods for binary and ordinal quantification.
In Proceedings of the 10th InternationalWorkshop on Semantic Evaluation (SemEval’16).
Association for Computational Linguistics, A, 5863.</p>
<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallTreeClassifier.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the set of estimators for the training set following the Frank and Hall decomposition and builds
the binary tree to organize such estimators</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator is None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallTreeClassifier.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the class for each testing example</p>
<p>The method computes the probability of each class (using <cite>predict_proba</cite>) and returns the class with
highest probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>An array, shape(n_examples, ) with the predicted class for each example</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotFittedError</strong> – When the estimators are not fitted yet</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#FrankAndHallTreeClassifier.predict_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the class probabilities for each example applying the binary tree of models</p>
<p class="rubric">Example</p>
<p>1-2-3 vs 4-5</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1 vs 2-3-4-5                            1-2-3-4 vs 5</p>
</div></blockquote>
<dl class="simple">
<dt>1                1-2 vs 3-4-5           4                5</dt><dd><p>2              3</p>
</dd>
</dl>
</div></blockquote>
<p>Imagine that for a given example the probabily returned by each model are the following (the models
return the probability of the left group of classes):</p>
<p>Pr({1,2,3}) = 0.2
Pr({1}) = 0.9
Pr({1,2,3,4}) = 0.7
Pr({1,2}) = 0.4</p>
<p>with tha values, the probability for each class will be:</p>
<p>Pr({1}) = Pr({1,2,3}) * Pr({1}) = 0.2 * 0.9 = 0.18
Pr({2}) = Pr({1,2,3}) * (1-Pr({1})) * Pr({1,2}) = 0.2 * 0.1 * 0.4 = 0.008
Pr({3}) = Pr({1,2,3}) * (1-Pr({1})) * (1-Pr({1,2})) = 0.2 * 0.1 * 0.6 = 0.012
Pr({4}) = (1-Pr({1,2,3}) * Pr{1,2,3,4}) = 0.8 * 0.7 = 0.56
Pr({5}) = (1-Pr({1,2,3}) * (1-Pr{1,2,3,4})) = 0.8 * 0.3 = 0.24</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>An array, shape(n_examples, n_classes) with the class probabilities for each example</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotFittedError</strong> – When the estimators are not fitted yet</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.QTree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">QTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fhtree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_estimator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#QTree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.QTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Auxiliar class to represent the binary trees needed by FrankAndHallTreeClassifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fhqtree</strong> (<em>FrankAndHallTreeClassifier object</em><em>  (</em><em>default=None</em><em>)</em>) – </p></li>
<li><p><strong>pos_estimator</strong> (<em>int</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – Index of the estimator in the order defined by the Frank and Hall decomposition: 1 vs 2-3-4-5, 1-2 vs 3-4-5
and so on.</p></li>
<li><p><strong>left</strong> (<em>a QTree object</em><em> (</em><em>default=None</em><em>)</em>) – Left subTree of this node</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>right: a QTree object (default=None)</dt><dd><p>Right subTree of this node</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.frank_and_hall.QTree.is_leaf">
<span class="sig-name descname"><span class="pre">is_leaf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/frank_and_hall.html#QTree.is_leaf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.frank_and_hall.QTree.is_leaf" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether it is a leaf or not</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-quantificationlib.estimators.ordinal_ddag">
<span id="quantificationlib-estimators-ordinal-ddag-module"></span><h2>quantificationlib.estimators.ordinal_ddag module<a class="headerlink" href="#module-quantificationlib.estimators.ordinal_ddag" title="Permalink to this heading">¶</a></h2>
<p>Estimator based on DDAGs (Decision Directed Acyclic Graphs)</p>
<dl class="py class">
<dt class="sig sig-object py" id="quantificationlib.estimators.ordinal_ddag.DDAGClassifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">DDAGClassifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predict_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full_probabilistic'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/ordinal_ddag.html#DDAGClassifier"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">OneVsOneClassifier</span></code></p>
<p>Decision Directed Acyclic Graph ordinal classifier</p>
<p>This strategy consists on learning a classifier per each pair of classes, thus it requires to fit
n_classes * (n_classes - 1) / 2 classifiers. For this reason, this class derives from OneVsOneClassifier and
uses most of its functionalities, mainly to train the binary models.</p>
<p>However, there are two main differences with respect to OneVsOneClassifier:</p>
<ol class="arabic">
<li><p>This class is used for ordinal classification, it does not make sense to use it for multiclass classification</p></li>
<li><p>The rule to make predictions is different. Here, the binary classifiers are arranged into a binary tree in
which the classifier selected at each node is the one that deals with the two more distant remaining
classes. Thus, the root contains the classifier that decides between the first class of the order and last
class, and this idea is recursively applied.</p>
<blockquote>
<div><p>Example: in a ordinal classification problem with classes ranging from 1-star to 5-star,
the corresponding DDAG will be</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1|5</p>
</div></blockquote>
<p>1|4                                       2|5</p>
</div></blockquote>
<p>1|3                 2|4                   2|4                  3|5</p>
</div></blockquote>
<p>1|2       2|3       2|3       3|4         2|3       3|4        3|4       4|5</p>
</div></blockquote>
<p>1     2   2     3   2     3   3     4     2     3   3     4    3     4   4     5</p>
</div></blockquote>
<p>Since some subtrees are shared by different branches, for instance, the subtree labeled as node
2|4 is shared by the right subtree of 1|4 and the left subtree of 2|5, the tree can be depicted in a more
compact way:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>1|5</p>
</div></blockquote>
<p>1|4             2|5</p>
</div></blockquote>
<p>1|3            2|4            3|5</p>
</div></blockquote>
<p>1|2          2|3             3|4           4|5</p>
</div></blockquote>
<p>1          2              3              4             5</p>
</div></blockquote>
<p>in which all internal nodes (2|4, 2|3 and 3|4) and all leaves, except the first one, and the last one
(2, 3 and 4) are reached from different paths.</p>
</div></blockquote>
</li>
</ol>
<p>The class implements two different strategies to compute the probabilities for a given example:</p>
<dl>
<dt>‘full_probabilistic’</dt><dd><p>The probabilities computed by each node are propagated through the tree. For those leaves that
can be reached following different paths (all except the leaves for the first and the last class), the
probabilities are summed. With this method, all the classes may have a probability greater that 0.</p>
<p>Example: For a given example, the probability of the left class returned by each model is the following:</p>
<p>P(1|5) = 0.2
P(1|4) = 0.1
P(2|5) = 0.1
P(1|3) = 0.2
P(2|4) = 0.3
P(3|5) = 0.3
P(1|2) = 0.3
P(2|3) = 0.4
P(3|4) = 0.4
P(4|5) = 0.3</p>
<dl>
<dt>P(y=1) = P(1|5) * P(1|4) * P(1|3) * P(1|2) =</dt><dd><p>0.2    * 0.1    * 0.2    * 0.3    = 0.0012</p>
</dd>
<dt>P(y=2) = P(1|5)     * P(1|4)     * P(1|3)     * (1-P(1|2)) +</dt><dd><p>P(1|5)     * P(1|4)     * (1-P(1|3)) * P(2|3)     +
P(1|5)     * (1-P(1|4)) * P(2|4)     * P(2|3)     +
(1-P(1|5)) * P(2|5)     * P(2|4)     * P(2|3)     =
0.2        * 0.1        * 0.2        * 0.7        +
0.2        * 0.1        * 0.8        * 0.4        +
0.2        * 0.9        * 0.3        * 0.4        +
0.8        * 0.1        * 0.3        * 0.4        = 0.0028 + 0.0064 + 0.0216 + 0.0096 = 0.0404</p>
</dd>
<dt>P(y=3) = P(1|5)     * P(1|4)     * (1-P(1|3)) * (1-P(2|3)) +</dt><dd><p>P(1|5)     * (1-P(1|4)) * P(2|4))    * (1-P(2|3)) +
P(1|5)     * (1-P(1|4)) * (1-P(2|4)) * P(3|4)     +
(1-P(1|5)) * P(2|5)     * P(2|4))    * (1-P(2|3)) +
(1-P(1|5)) * P(2|5)     * (1-P(2|4)) * P(3|4)     +
(1-P(1|5)) * (1-P(2|5)) * P(3|5)     * P(3|4)     =
0.2        * 0.1        * 0.8        * 0.6        +
0.2        * 0.9        * 0.3        * 0.6        +
0.2        * 0.9        * 0.7        * 0.4        +
0.8        * 0.1        * 0.3        * 0.6        +
0.8        * 0.1        * 0.7        * 0.4        +
0.8        * 0.9        * 0.3        * 0.4        = 0.0096 + 0.0324 + 0.0504 +</p>
<blockquote>
<div><p>0.0144 + 0.0224 + 0.0864 = 0.2156</p>
</div></blockquote>
</dd>
<dt>P(y=4) = P(1|5)     * (1-P(1|4)) * (1-P(2|4)) * (1-P(3|4)) +</dt><dd><p>(1-P(1|5)) * P(2|5)     * (1-P(2|4)) * (1-P(3|4)) +
(1-P(1|5)) * (1-P(2|5)) * P(3|5)     * (1-P(3|4)) +
(1-P(1|5)) * (1-P(2|5)) * (1-P(3|5)) * P(4|5)     =
0.2        * 0.9        * 0.7        * 0.6        + 0.0756
0.8        * 0.1        * 0.7        * 0.6        + 0.0336
0.8        * 0.9        * 0.3        * 0.6        + 0.1296
0.8        * 0.9        * 0.7        * 0.3        = 0.0756 + 0.0336 + 0.1296 + 0.1512 = 0.3900</p>
</dd>
<dt>P(y=5) = (1-P(1|5)) * (1-P(2|5)) * (1-P(3|5)) * (1-P(4|5)) =</dt><dd><p>0.8        * 0.9        * 0.7        * 0.7        = 0.3528</p>
</dd>
</dl>
<p>Thus, the probabilities returned by <cite>predict_proba</cite> method would be (0.0012, 0.0404, 02156, 0.3900, 0.3528)</p>
</dd>
<dt>‘winner_node’</dt><dd><p>Uses the probabilities of binary estimators to descent until the level previous to the leaves (it is like
binarizing such probabilities to 0,1). Then, the method returns the probalities of such binary estimator
for the two consecutive classes involved, and zero for the rest of classes.</p>
<p>Example: For a given example, the probability of the left class returned by each model is the following:</p>
<p>P(1|5) = 0.2
P(1|4) = 0.1
P(2|5) = 0.1
P(1|3) = 0.2
P(2|4) = 0.3
P(3|5) = 0.3
P(1|2) = 0.3
P(2|3) = 0.4
P(3|4) = 0.4
P(4|5) = 0.3</p>
<p>Taking binary decisions from the root, we reach the binary classifier 4|5, thus the returned probabilities
are (0, 0, 0, 0.3, 0.7)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is the base estimator
used to learn the set of binary classifiers</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The number of jobs to use for the computation.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <span class="xref std std-term">Glossary</span>
for more details.</p></li>
<li><p><strong>predict_method</strong> (<em>str</em><em>, </em><em>optional</em><em> (</em><em>default 'full_probabilistic'</em><em>)</em>) – <p>‘full_probabilistic’
The probabilities computed by each node are propagated through the tree. For those leaves that
can be reached following different paths (all except the leaves for the first and the last class), the
probabilities are summed. With this method, all the classes may have a probability greater that 0.</p>
<p>’winner_node’
Uses the probabilities of binary estimators to descent until the level previous to the leaves (it is like
binarizing such probabilities to 0,1). Then, the method returns the probalities of such binary estimator
for the two consecutive classes involved, and zero for the rest of classes.</p>
</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ordinal_ddag.DDAGClassifier.estimator">
<span class="sig-name descname"><span class="pre">estimator</span></span><a class="headerlink" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>An estimator object implementing <cite>fit</cite> and <cite>predict_proba</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ordinal_ddag.DDAGClassifier.n_jobs">
<span class="sig-name descname"><span class="pre">n_jobs</span></span><a class="headerlink" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.n_jobs" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of jobs to use for the computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int or None,</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ordinal_ddag.DDAGClassifier.predict_method">
<span class="sig-name descname"><span class="pre">predict_method</span></span><a class="headerlink" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.predict_method" title="Permalink to this definition">¶</a></dt>
<dd><p>The method used by <cite>predict_proba</cite> to compute the class probabilities of a given example</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ordinal_ddag.DDAGClassifier.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>The verbosity level.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int,</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ordinal_ddag.DDAGClassifier.estimators_">
<span class="sig-name descname"><span class="pre">estimators_</span></span><a class="headerlink" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.estimators_" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimators used for predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of <code class="docutils literal notranslate"><span class="pre">n_classes</span> <span class="pre">*</span> <span class="pre">(n_classes</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">/</span> <span class="pre">2</span></code> estimators</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.ordinal_ddag.DDAGClassifier.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.classes_" title="Permalink to this definition">¶</a></dt>
<dd><p>Array containing labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy array of shape [n_classes]</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">References</p>
<p>José Ramón Quevedo, Elena Montañés, Óscar Luaces, Juan José del Coz: Adapting decision DAGs for multipartite
ranking. In Joint European Conference on Machine Learning and Knowledge Discovery in Databases (pp. 115-130).
Springer, Berlin, Heidelberg.</p>
<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.ordinal_ddag.DDAGClassifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/ordinal_ddag.html#DDAGClassifier.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the class for each testing example</p>
<p>The method computes the probability of each class (using <cite>predict_proba</cite>) and returns the class with
highest probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>An array, shape(n_examples, ) with the predicted class for each example</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotFittedError</strong> – When the estimators are not fitted yet</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.ordinal_ddag.DDAGClassifier.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/ordinal_ddag.html#DDAGClassifier.predict_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the class probabilities for each example</p>
<p>Two different methods are implemented depending on the value of <cite>predict_method</cite> attribute</p>
<p>‘full_probabilistic’
The probabilities computed by each node are propagated through the tree. For those leaves that
can be reached following different paths (all except the leaves for the first and the last class), the
probabilities are summed. With this method, all the classes may have a probability greater that 0.</p>
<p>‘winner_node’
Uses the probabilities of binary estimators to descent until the level previous to the leaves (it is like
binarizing such probabilities to 0,1). Then, the method returns the probalities of such binary estimator
for the two consecutive classes involved, and zero for the rest of classes.</p>
<p>The method uses a recursive auxiliar method to compute the class probabilities</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>An array, shape(n_examples, n_classes) with the class probabilities for each example</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotFittedError</strong> – When the estimators are not fitted yet</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-quantificationlib.estimators.weighted_knn">
<span id="quantificationlib-estimators-weighted-knn-module"></span><h2>quantificationlib.estimators.weighted_knn module<a class="headerlink" href="#module-quantificationlib.estimators.weighted_knn" title="Permalink to this heading">¶</a></h2>
<p>Proportion-weighted K-Nearest Neighbor Classifier</p>
<dl class="py class">
<dt class="sig sig-object py" id="quantificationlib.estimators.weighted_knn.PWK">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PWK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'minkowski'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/weighted_knn.html#PWK"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.weighted_knn.PWK" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ClassifierMixin</span></code></p>
<p>Proportion-weighted k-Nearest Neighbor Classifier</p>
<p>This class is an kind of wrapper of sklearn.neighbors.KNeighborsClassifier (version 1.0.2) to use
class-dependent weights to deal with imbalanced problems. The parameters are the same, except weights
that are computed by this class</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_neighbors</strong> (<em>int</em><em>, </em><em>(</em><em>default=10</em><em>)</em>) – Number of neighbors to use by default for <code class="xref py py-meth docutils literal notranslate"><span class="pre">kneighbors()</span></code> queries.</p></li>
<li><p><strong>algorithm</strong> (<em>{'auto'</em><em>, </em><em>'ball_tree'</em><em>, </em><em>'kd_tree'</em><em>, </em><em>'brute'}</em><em>, </em><em>default='auto'</em>) – <p>Algorithm used to compute the nearest neighbors:
- ‘ball_tree’ will use <code class="xref py py-class docutils literal notranslate"><span class="pre">BallTree</span></code>
- ‘kd_tree’ will use <code class="xref py py-class docutils literal notranslate"><span class="pre">KDTree</span></code>
- ‘brute’ will use a brute-force search.
- ‘auto’ will attempt to decide the most appropriate algorithm</p>
<blockquote>
<div><p>based on the values passed to <a class="reference internal" href="rsts_t4/quantificationlib.estimators.weighted_knn.html#quantificationlib.estimators.weighted_knn.PWK.fit" title="quantificationlib.estimators.weighted_knn.PWK.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> method.</p>
</div></blockquote>
<p>Note: fitting on sparse input will override the setting of
this parameter, using brute force.</p>
</p></li>
<li><p><strong>leaf_size</strong> (<em>int</em><em>, </em><em>default=30</em>) – Leaf size passed to BallTree or KDTree.  This can affect the
speed of the construction and query, as well as the memory
required to store the tree.  The optimal value depends on the
nature of the problem.</p></li>
<li><p><strong>p</strong> (<em>int</em><em>, </em><em>default=2</em>) – Power parameter for the Minkowski metric. When p = 1, this is
equivalent to using manhattan_distance (l1), and euclidean_distance
(l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used.</p></li>
<li><p><strong>metric</strong> (<em>str</em><em> or </em><em>callable</em><em>, </em><em>default='minkowski'</em>) – The distance metric to use for the tree.  The default metric is
minkowski, and with p=2 is equivalent to the standard Euclidean
metric. For a list of available metrics, see the documentation of
<code class="xref py py-class docutils literal notranslate"><span class="pre">DistanceMetric</span></code>.
If metric is “precomputed”, X is assumed to be a distance matrix and
must be square during fit. X may be a <span class="xref std std-term">sparse graph</span>,
in which case only “nonzero” elements may be considered neighbors.</p></li>
<li><p><strong>metric_params</strong> (<em>dict</em><em>, </em><em>default=None</em>) – Additional keyword arguments for the metric function.</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em>, </em><em>default=None</em>) – The number of parallel jobs to run for neighbors search.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code> context.
<code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors. See <span class="xref std std-term">Glossary</span>
for more details.
Doesn’t affect <a class="reference internal" href="rsts_t4/quantificationlib.estimators.weighted_knn.html#quantificationlib.estimators.weighted_knn.PWK.fit" title="quantificationlib.estimators.weighted_knn.PWK.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> method.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.weighted_knn.PWK.knn_">
<span class="sig-name descname"><span class="pre">knn_</span></span><a class="headerlink" href="#quantificationlib.estimators.weighted_knn.PWK.knn_" title="Permalink to this definition">¶</a></dt>
<dd><p>KNN classifier</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>KNeighborsClassifier object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.weighted_knn.PWK.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#quantificationlib.estimators.weighted_knn.PWK.classes_" title="Permalink to this definition">¶</a></dt>
<dd><p>Class labels known to the classifier</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array of shape (n_classes,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.weighted_knn.PWK.weights_">
<span class="sig-name descname"><span class="pre">weights_</span></span><a class="headerlink" href="#quantificationlib.estimators.weighted_knn.PWK.weights_" title="Permalink to this definition">¶</a></dt>
<dd><p>The weight for each example</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array, shape (n_samples, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="quantificationlib.estimators.weighted_knn.PWK.y_">
<span class="sig-name descname"><span class="pre">y_</span></span><a class="headerlink" href="#quantificationlib.estimators.weighted_knn.PWK.y_" title="Permalink to this definition">¶</a></dt>
<dd><p>True labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.weighted_knn.PWK.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/weighted_knn.html#PWK.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.weighted_knn.PWK.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the k-nearest neighbors classifier and compute the weights using the training dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.weighted_knn.PWK.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/weighted_knn.html#PWK.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.weighted_knn.PWK.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the crisp predictions for the provided data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Test ata</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>preds</strong> – Crisp predictions for the examples in X</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape shape(n_examples, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="quantificationlib.estimators.weighted_knn.PWK.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/quantificationlib/estimators/weighted_knn.html#PWK.predict_proba"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#quantificationlib.estimators.weighted_knn.PWK.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the probabilistic predictions for the provided data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Test ata</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>preds</strong> – Probabilistic predictions for the examples in X</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like, shape shape(n_examples, n_classes)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-quantificationlib.estimators">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-quantificationlib.estimators" title="Permalink to this heading">¶</a></h2>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">





<h3><a href="index.html">Table of Contents</a></h3>
<ul>
<li><a class="reference internal" href="#">quantificationlib.estimators package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-quantificationlib.estimators.cross_validation">quantificationlib.estimators.cross_validation module</a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator"><code class="docutils literal notranslate"><span class="pre">CV_estimator</span></code></a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.estimator"><code class="docutils literal notranslate"><span class="pre">estimator</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.estimators_"><code class="docutils literal notranslate"><span class="pre">estimators_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.averaged_predictions"><code class="docutils literal notranslate"><span class="pre">averaged_predictions</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.voting"><code class="docutils literal notranslate"><span class="pre">voting</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.le_"><code class="docutils literal notranslate"><span class="pre">le_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.classes_"><code class="docutils literal notranslate"><span class="pre">classes_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.X_train_"><code class="docutils literal notranslate"><span class="pre">X_train_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.y_train_"><code class="docutils literal notranslate"><span class="pre">y_train_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.verbose"><code class="docutils literal notranslate"><span class="pre">verbose</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.fit"><code class="docutils literal notranslate"><span class="pre">fit()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.predict"><code class="docutils literal notranslate"><span class="pre">predict()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.cross_validation.CV_estimator.predict_proba"><code class="docutils literal notranslate"><span class="pre">predict_proba()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-quantificationlib.estimators.ensembles">quantificationlib.estimators.ensembles module</a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers"><code class="docutils literal notranslate"><span class="pre">EnsembleOfClassifiers</span></code></a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.base_estimator"><code class="docutils literal notranslate"><span class="pre">base_estimator</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.n_jobs"><code class="docutils literal notranslate"><span class="pre">n_jobs</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.verbose"><code class="docutils literal notranslate"><span class="pre">verbose</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.classes_"><code class="docutils literal notranslate"><span class="pre">classes_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.n_estimators_"><code class="docutils literal notranslate"><span class="pre">n_estimators_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.estimators_"><code class="docutils literal notranslate"><span class="pre">estimators_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.fit"><code class="docutils literal notranslate"><span class="pre">fit()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.predict"><code class="docutils literal notranslate"><span class="pre">predict()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ensembles.EnsembleOfClassifiers.predict_proba"><code class="docutils literal notranslate"><span class="pre">predict_proba()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-quantificationlib.estimators.frank_and_hall">quantificationlib.estimators.frank_and_hall module</a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FHLabelBinarizer"><code class="docutils literal notranslate"><span class="pre">FHLabelBinarizer</span></code></a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FHLabelBinarizer.transform"><code class="docutils literal notranslate"><span class="pre">transform()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier"><code class="docutils literal notranslate"><span class="pre">FrankAndHallClassifier</span></code></a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.estimator"><code class="docutils literal notranslate"><span class="pre">estimator</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.n_jobs"><code class="docutils literal notranslate"><span class="pre">n_jobs</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.params_fit"><code class="docutils literal notranslate"><span class="pre">params_fit</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.verbose"><code class="docutils literal notranslate"><span class="pre">verbose</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.classes_"><code class="docutils literal notranslate"><span class="pre">classes_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.estimators_"><code class="docutils literal notranslate"><span class="pre">estimators_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.label_binarizer_"><code class="docutils literal notranslate"><span class="pre">label_binarizer_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.compute_binary_proba"><code class="docutils literal notranslate"><span class="pre">compute_binary_proba()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.fit"><code class="docutils literal notranslate"><span class="pre">fit()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.predict"><code class="docutils literal notranslate"><span class="pre">predict()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallClassifier.predict_proba"><code class="docutils literal notranslate"><span class="pre">predict_proba()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier"><code class="docutils literal notranslate"><span class="pre">FrankAndHallMonotoneClassifier</span></code></a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.estimator"><code class="docutils literal notranslate"><span class="pre">estimator</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.n_jobs"><code class="docutils literal notranslate"><span class="pre">n_jobs</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.verbose"><code class="docutils literal notranslate"><span class="pre">verbose</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.params_fit"><code class="docutils literal notranslate"><span class="pre">params_fit</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.classes_"><code class="docutils literal notranslate"><span class="pre">classes_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.estimators_"><code class="docutils literal notranslate"><span class="pre">estimators_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.label_binarizer_"><code class="docutils literal notranslate"><span class="pre">label_binarizer_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.fit"><code class="docutils literal notranslate"><span class="pre">fit()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.predict"><code class="docutils literal notranslate"><span class="pre">predict()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallMonotoneClassifier.predict_proba"><code class="docutils literal notranslate"><span class="pre">predict_proba()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier"><code class="docutils literal notranslate"><span class="pre">FrankAndHallTreeClassifier</span></code></a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.estimator"><code class="docutils literal notranslate"><span class="pre">estimator</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.n_jobs"><code class="docutils literal notranslate"><span class="pre">n_jobs</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.performance_measure"><code class="docutils literal notranslate"><span class="pre">performance_measure</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.verbose"><code class="docutils literal notranslate"><span class="pre">verbose</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.params_fit"><code class="docutils literal notranslate"><span class="pre">params_fit</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.classes_"><code class="docutils literal notranslate"><span class="pre">classes_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.estimators_"><code class="docutils literal notranslate"><span class="pre">estimators_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.label_binarizer_"><code class="docutils literal notranslate"><span class="pre">label_binarizer_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.tree_"><code class="docutils literal notranslate"><span class="pre">tree_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.fit"><code class="docutils literal notranslate"><span class="pre">fit()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.predict"><code class="docutils literal notranslate"><span class="pre">predict()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.FrankAndHallTreeClassifier.predict_proba"><code class="docutils literal notranslate"><span class="pre">predict_proba()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.QTree"><code class="docutils literal notranslate"><span class="pre">QTree</span></code></a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.frank_and_hall.QTree.is_leaf"><code class="docutils literal notranslate"><span class="pre">is_leaf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-quantificationlib.estimators.ordinal_ddag">quantificationlib.estimators.ordinal_ddag module</a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier"><code class="docutils literal notranslate"><span class="pre">DDAGClassifier</span></code></a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.estimator"><code class="docutils literal notranslate"><span class="pre">estimator</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.n_jobs"><code class="docutils literal notranslate"><span class="pre">n_jobs</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.predict_method"><code class="docutils literal notranslate"><span class="pre">predict_method</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.verbose"><code class="docutils literal notranslate"><span class="pre">verbose</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.estimators_"><code class="docutils literal notranslate"><span class="pre">estimators_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.classes_"><code class="docutils literal notranslate"><span class="pre">classes_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.predict"><code class="docutils literal notranslate"><span class="pre">predict()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.ordinal_ddag.DDAGClassifier.predict_proba"><code class="docutils literal notranslate"><span class="pre">predict_proba()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-quantificationlib.estimators.weighted_knn">quantificationlib.estimators.weighted_knn module</a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.weighted_knn.PWK"><code class="docutils literal notranslate"><span class="pre">PWK</span></code></a><ul>
<li><a class="reference internal" href="#quantificationlib.estimators.weighted_knn.PWK.knn_"><code class="docutils literal notranslate"><span class="pre">knn_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.weighted_knn.PWK.classes_"><code class="docutils literal notranslate"><span class="pre">classes_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.weighted_knn.PWK.weights_"><code class="docutils literal notranslate"><span class="pre">weights_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.weighted_knn.PWK.y_"><code class="docutils literal notranslate"><span class="pre">y_</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.weighted_knn.PWK.fit"><code class="docutils literal notranslate"><span class="pre">fit()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.weighted_knn.PWK.predict"><code class="docutils literal notranslate"><span class="pre">predict()</span></code></a></li>
<li><a class="reference internal" href="#quantificationlib.estimators.weighted_knn.PWK.predict_proba"><code class="docutils literal notranslate"><span class="pre">predict_proba()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-quantificationlib.estimators">Module contents</a></li>
</ul>
</li>
</ul>




  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/quantificationlib.estimators.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">quantificationlib 0.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">quantificationlib.estimators package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Jaime.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
    </div>
  </body>
</html>